This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-01T06:50:30.114Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  derived_stuff.rs
  from_hashmap.rs
  lib.rs
tests/
  from_hashmap_test.rs
.gitignore
Cargo.toml
README.md

================================================================
Files
================================================================

================
File: src/derived_stuff.rs
================
use proc_macro::TokenStream;
use quote::quote;
use serde_json;
use syn::{parse_macro_input, Data, DeriveInput, Fields, Type, TypePath};

#[cfg_attr(feature = "extra-traits", derive(Debug, Eq, PartialEq, Hash))]
pub(crate) fn derive_stuff_impl(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let struct_name = &input.ident;
   
    let fields = if let Data::Struct(data) = &input.data {
        if let Fields::Named(fields) = &data.fields {
            fields
        } else {
            panic!("FromHashMap can only be derived on structs with named fields.");
        }
    } else {
        panic!("FromHashMap can only be derived on structs.");
    };

   
    let field_mappings = fields.named.iter().map(|f| {
        let field_name = &f.ident;
        let field_str = field_name.as_ref().unwrap().to_string();
        let ty = &f.ty;
       
        
        // Handle nested struct types
        if let Type::Path(TypePath { path, .. }) = ty {
            let type_name = quote!(#path).to_string();

            if type_name.starts_with("Vec <") {
                return quote! {
                    #field_name: fields.get(#field_str)
                        .map(|val| val.split(',')
                            .filter_map(|s| s.trim().parse().ok())
                            .collect()
                        ).unwrap_or_default(),
                };

              
            }


            //TODO nested
            if !["String", "u8", "u16", "i32", "f64", "bool", "Option"]
                .iter()
                .any(|&t| type_name.contains(t))
            {
                return quote! {
                    #field_name: fields.iter()
                        .filter(|(k, _)| k.starts_with(&(#field_str.to_string() + ".")))
                        .map(|(k, v)| (k.trim_start_matches(&(#field_str.to_string() + ".")).to_string(), v.clone()))
                        .collect::<std::collections::HashMap<String, String>>()
                        .into(),
                };
            }
        }

        // Handle specific primitive types
        if quote!(#ty).to_string().contains("Option") {
            quote! {
                #field_name: fields.get(#field_str).cloned(),
            }
        } else if quote!(#ty).to_string().contains("u8") {
            quote! {
                #field_name: fields.get(#field_str)
                    .and_then(|val| val.parse::<u8>().ok())
                    .unwrap_or_default(),
            }
        } else if quote!(#ty).to_string().contains("i32") {
            quote! {
                #field_name: fields.get(#field_str)
                    .and_then(|val| val.parse::<i32>().ok())
                    .unwrap_or_default(),
            }
        } else if quote!(#ty).to_string().contains("f64") {
            quote! {
                #field_name: fields.get(#field_str)
                    .and_then(|val| val.parse::<f64>().ok())
                    .unwrap_or_default(),
            }
        } else {
            quote! {
                #field_name: fields.get(#field_str).cloned().unwrap_or_default(),
            }
        }
    });

    let expanded = quote! {
        impl From<std::collections::HashMap<String, String>> for #struct_name {
            fn from(fields: std::collections::HashMap<String, String>) -> Self {
                Self {
                    #(#field_mappings)*
                }
            }
        }
    };

    TokenStream::from(expanded)
    
}

use quote::ToTokens;
use std::fmt;

struct DebugType<'a>(&'a Type);

impl<'a> fmt::Debug for DebugType<'a> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.0.to_token_stream())
    }
}

fn debug_syn<T: serde::Serialize>(syn_type: &T) {
    println!("{}", serde_json::to_string_pretty(syn_type).unwrap());
}

================
File: src/from_hashmap.rs
================
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, Data, DeriveInput, Fields, Type, TypePath};


#[cfg_attr(feature = "extra-traits", derive(Debug, Eq, PartialEq, Hash))]
pub(crate) fn derive_from_hashmap_impl(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let struct_name = &input.ident;
   
    let fields = if let Data::Struct(data) = &input.data {
        if let Fields::Named(fields) = &data.fields {
            fields
        } else {
            panic!("FromHashMap can only be derived on structs with named fields.");
        }
    } else {
        panic!("FromHashMap can only be derived on structs.");
    };

    let field_mappings = fields.named.iter().map(|f| {
        let field_name = &f.ident;
        let field_str = field_name.as_ref().unwrap().to_string();
        let ty = &f.ty;

        // Handle nested struct types
        if let Type::Path(TypePath { path, .. }) = ty {
            let type_name = quote!(#path).to_string();


            //TODO
            if !["String", "u8", "u16", "i32", "f64", "bool", "Option"]
                .iter()
                .any(|&t| type_name.contains(t))
            {
                return quote! {
                    #field_name: fields.iter()
                        .filter(|(k, _)| k.starts_with(&(#field_str.to_string() + ".")))
                        .map(|(k, v)| (k.trim_start_matches(&(#field_str.to_string() + ".")).to_string(), v.clone()))
                        .collect::<std::collections::HashMap<String, String>>()
                        .into(),
                };
            }
        }

        // Handle specific primitive types
        if quote!(#ty).to_string().contains("Option") {
            quote! {
                #field_name: fields.get(#field_str).cloned(),
            }
        } else if quote!(#ty).to_string().contains("u8") {
            quote! {
                #field_name: fields.get(#field_str)
                    .and_then(|val| val.parse::<u8>().ok())
                    .unwrap_or_default(),
            }
        } else if quote!(#ty).to_string().contains("i32") {
            quote! {
                #field_name: fields.get(#field_str)
                    .and_then(|val| val.parse::<i32>().ok())
                    .unwrap_or_default(),
            }
        } else if quote!(#ty).to_string().contains("f64") {
            quote! {
                #field_name: fields.get(#field_str)
                    .and_then(|val| val.parse::<f64>().ok())
                    .unwrap_or_default(),
            }
        } else {
            quote! {
                #field_name: fields.get(#field_str).cloned().unwrap_or_default(),
            }
        }
    });

    let expanded = quote! {
        impl From<std::collections::HashMap<String, String>> for #struct_name {
            fn from(fields: std::collections::HashMap<String, String>) -> Self {
                Self {
                    #(#field_mappings)*
                }
            }
        }
    };

    TokenStream::from(expanded)
}

================
File: src/lib.rs
================
extern crate proc_macro;

use proc_macro::TokenStream;

mod from_hashmap;
mod derived_stuff;


#[proc_macro_derive(FromHashMap)]
pub fn from_hashmap_derive(input: TokenStream) -> TokenStream {
    from_hashmap::derive_from_hashmap_impl(input).into()
}

///  `DerivedStuff` (for debugging)
#[proc_macro_derive(DerivedStuff)]
pub fn derived_stuff(input: TokenStream) -> TokenStream {
    derived_stuff::derive_stuff_impl(input)
}

================
File: tests/from_hashmap_test.rs
================
use doless::{DerivedStuff, FromHashMap};
use std::collections::HashMap;

#[derive(FromHashMap, Debug)]
struct Car {
    model: String,
    brand: String,
    an_option_field: Option<String>,
    number: u8,
    details: CarDetails,
}

#[derive(FromHashMap, Debug)]
struct CarDetails {
    name: String,
    description: String,
}

#[derive(DerivedStuff, Debug)]
struct CarDetailsX {
    vec_string: Vec<String>,
    vec_u8: Vec<u8>,
    name: String,
    description: String,
    //vec_option: Vec<Option<String>>,
}

#[test]
fn test_from_hashmap() {
    let mut data = HashMap::new();
    data.insert("model".to_string(), "GT-R".to_string());
    data.insert("brand".to_string(), "Nissan".to_string());
    data.insert("number".to_string(), "8".to_string());
    data.insert("details.name".to_string(), "v8engine".to_string());
    data.insert("details.description".to_string(), "500hp".to_string());

    let car: Car = Car::from(data);

    assert_eq!(car.model, "GT-R");
    assert_eq!(car.brand, "Nissan");
    assert_eq!(car.number, 0b1000);
    assert_eq!(car.an_option_field, None);
    assert_eq!(car.details.name, "v8engine");
    assert_eq!(car.details.description, "500hp");
}

#[test]
fn test_from() {
    let mut data = HashMap::new();
    data.insert("vec_string".to_string(), "hello, world, rust".to_string());
    data.insert("vec_u8".to_string(), "1, 2, 999".to_string());
    let car_details: CarDetailsX = CarDetailsX::from(data);
    // let x = CarDetailsX{
    //     vectest: vec![String::from("hello")]
    // };
    println!("{:?}", car_details)
}

================
File: .gitignore
================
debug/
target/
Cargo.lock
**/*.rs.bk
*.pdb

================
File: Cargo.toml
================
[package]
name = "doless"
version = "0.2.0"
edition = "2021"
description = "A Rust macro to simplify struct mapping and function utilities."
license = "MIT OR Apache-2.0"
repository = "https://github.com/nawajar/DoLess"
keywords = ["macro", "procedural", "struct", "mapping", "timing"]
categories = ["development-tools", "rust-patterns"]
readme = "README.md"

[dependencies]
syn = { version = "2", features = ["full", "extra-traits"] }
quote = "1"
proc-macro2 = "1"
proc-macro-error = { version = "1", default-features = false }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"





[lib]
proc-macro = true

================
File: README.md
================
# DoLess - Procedural Macro for Struct Mapping 🦀

`DoLess` is a Rust **procedural macro** that allows structs to be initialized from a `HashMap<String, String>`. It automatically maps field values, providing **type-safe conversions**.

## 🚀 Features
- 🏢 **Auto-implements `From<HashMap<String, String>>`** for structs.
- 🔄 **Supports common Rust types** (`String`, `u8`, `u16`, `i32`, `f64`, `Option`, etc.).
- ❌ **Compile-time errors for unsupported types**.
- ✅ **Default values for missing fields**.
- ⚙ **Supports nested struct parsing** with `.` notation.

---

## 📦 Installation
Add `DoLess` to your `Cargo.toml`:

```toml
[dependencies]
doless = "0.2.0"
```

## 👺 Usage

### Basic Struct Mapping
```rust
use doless::FromHashMap;
use std::collections::HashMap;

#[derive(FromHashMap, Debug, PartialEq)]
struct Car {
    model: String,
    year: u16,
}

fn main() {
    let mut data = HashMap::new();
    data.insert("model".to_string(), "GT-R".to_string());
    data.insert("year".to_string(), "2023".to_string());

    let car: Car = Car::from(data);
    println!("Car: Model = {}, Year = {}", car.model, car.year);
}
```

### Nested Struct Support

```rust
use doless::FromHashMap;
use std::collections::HashMap;

#[derive(FromHashMap, Debug)]
struct Car {
    model: String,
    brand: String,
    number: u8,
    details: CarDetails,  // ✅ Nested Struct Support
}

#[derive(FromHashMap, Debug)]
struct CarDetails {
    name: String,
    description: String,
}

fn main() {
    let mut data = HashMap::new();
    data.insert("model".to_string(), "GT-R".to_string());
    data.insert("brand".to_string(), "Nissan".to_string());
    data.insert("number".to_string(), "8".to_string());

    // ✅ Nested Fields with Prefix Notation
    data.insert("details.name".to_string(), "Skyline".to_string());
    data.insert("details.description".to_string(), "Legendary Sports Car".to_string());

    let car: Car = Car::from(data);
    println!("{:?}", car);
}
```

### Expected Output
```rust
Car {
    model: "GT-R",
    brand: "Nissan",
    number: 8,
    details: CarDetails {
        name: "Skyline",
        description: "Legendary Sports Car"
    }
}
```

---

## 🚀 Why Use DoLess?
- **Simple & Lightweight** — No runtime dependencies, just pure Rust.
- **Declarative API** — Uses procedural macros to generate efficient `From<HashMap<String, String>>` implementations.
- **Type-Safe & Extensible** — Ensures correct conversions and supports nesting.

### ⚙ Roadmap
- [x] Basic primitive types mapping
- [x] Nested struct support
- [ ] Custom conversion support
- [ ] Error handling improvements

---

**Happy coding! ✨**
